// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: proto/trading.proto
// </auto-generated>
#pragma warning disable 0414, 1591, 8981, 0612
#region Designer generated code

using grpc = global::Grpc.Core;

namespace Trading.Proto {
  /// <summary>
  /// Trading service for main communication
  /// </summary>
  public static partial class TradingService
  {
    static readonly string __ServiceName = "trading.TradingService";

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static void __Helper_SerializeMessage(global::Google.Protobuf.IMessage message, grpc::SerializationContext context)
    {
      #if !GRPC_DISABLE_PROTOBUF_BUFFER_SERIALIZATION
      if (message is global::Google.Protobuf.IBufferMessage)
      {
        context.SetPayloadLength(message.CalculateSize());
        global::Google.Protobuf.MessageExtensions.WriteTo(message, context.GetBufferWriter());
        context.Complete();
        return;
      }
      #endif
      context.Complete(global::Google.Protobuf.MessageExtensions.ToByteArray(message));
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static class __Helper_MessageCache<T>
    {
      public static readonly bool IsBufferMessage = global::System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(global::Google.Protobuf.IBufferMessage)).IsAssignableFrom(typeof(T));
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static T __Helper_DeserializeMessage<T>(grpc::DeserializationContext context, global::Google.Protobuf.MessageParser<T> parser) where T : global::Google.Protobuf.IMessage<T>
    {
      #if !GRPC_DISABLE_PROTOBUF_BUFFER_SERIALIZATION
      if (__Helper_MessageCache<T>.IsBufferMessage)
      {
        return parser.ParseFrom(context.PayloadAsReadOnlySequence());
      }
      #endif
      return parser.ParseFrom(context.PayloadAsNewBuffer());
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Trading.Proto.Trade> __Marshaller_trading_Trade = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Trading.Proto.Trade.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Trading.Proto.GenericResponse> __Marshaller_trading_GenericResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Trading.Proto.GenericResponse.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Trading.Proto.GetTradesRequest> __Marshaller_trading_GetTradesRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Trading.Proto.GetTradesRequest.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Trading.Proto.MT5TradeResult> __Marshaller_trading_MT5TradeResult = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Trading.Proto.MT5TradeResult.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Trading.Proto.HedgeCloseNotification> __Marshaller_trading_HedgeCloseNotification = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Trading.Proto.HedgeCloseNotification.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Trading.Proto.ElasticHedgeUpdate> __Marshaller_trading_ElasticHedgeUpdate = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Trading.Proto.ElasticHedgeUpdate.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Trading.Proto.TrailingStopUpdate> __Marshaller_trading_TrailingStopUpdate = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Trading.Proto.TrailingStopUpdate.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Trading.Proto.HealthRequest> __Marshaller_trading_HealthRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Trading.Proto.HealthRequest.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Trading.Proto.HealthResponse> __Marshaller_trading_HealthResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Trading.Proto.HealthResponse.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Trading.Proto.SettingsRequest> __Marshaller_trading_SettingsRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Trading.Proto.SettingsRequest.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Trading.Proto.SettingsResponse> __Marshaller_trading_SettingsResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Trading.Proto.SettingsResponse.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Trading.Proto.HeartbeatRequest> __Marshaller_trading_HeartbeatRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Trading.Proto.HeartbeatRequest.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Trading.Proto.HeartbeatResponse> __Marshaller_trading_HeartbeatResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Trading.Proto.HeartbeatResponse.Parser));

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Trading.Proto.Trade, global::Trading.Proto.GenericResponse> __Method_SubmitTrade = new grpc::Method<global::Trading.Proto.Trade, global::Trading.Proto.GenericResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SubmitTrade",
        __Marshaller_trading_Trade,
        __Marshaller_trading_GenericResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Trading.Proto.GetTradesRequest, global::Trading.Proto.Trade> __Method_GetTrades = new grpc::Method<global::Trading.Proto.GetTradesRequest, global::Trading.Proto.Trade>(
        grpc::MethodType.DuplexStreaming,
        __ServiceName,
        "GetTrades",
        __Marshaller_trading_GetTradesRequest,
        __Marshaller_trading_Trade);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Trading.Proto.MT5TradeResult, global::Trading.Proto.GenericResponse> __Method_SubmitTradeResult = new grpc::Method<global::Trading.Proto.MT5TradeResult, global::Trading.Proto.GenericResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SubmitTradeResult",
        __Marshaller_trading_MT5TradeResult,
        __Marshaller_trading_GenericResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Trading.Proto.HedgeCloseNotification, global::Trading.Proto.GenericResponse> __Method_NotifyHedgeClose = new grpc::Method<global::Trading.Proto.HedgeCloseNotification, global::Trading.Proto.GenericResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "NotifyHedgeClose",
        __Marshaller_trading_HedgeCloseNotification,
        __Marshaller_trading_GenericResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Trading.Proto.ElasticHedgeUpdate, global::Trading.Proto.GenericResponse> __Method_SubmitElasticUpdate = new grpc::Method<global::Trading.Proto.ElasticHedgeUpdate, global::Trading.Proto.GenericResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SubmitElasticUpdate",
        __Marshaller_trading_ElasticHedgeUpdate,
        __Marshaller_trading_GenericResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Trading.Proto.TrailingStopUpdate, global::Trading.Proto.GenericResponse> __Method_SubmitTrailingUpdate = new grpc::Method<global::Trading.Proto.TrailingStopUpdate, global::Trading.Proto.GenericResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SubmitTrailingUpdate",
        __Marshaller_trading_TrailingStopUpdate,
        __Marshaller_trading_GenericResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Trading.Proto.HealthRequest, global::Trading.Proto.HealthResponse> __Method_HealthCheck = new grpc::Method<global::Trading.Proto.HealthRequest, global::Trading.Proto.HealthResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "HealthCheck",
        __Marshaller_trading_HealthRequest,
        __Marshaller_trading_HealthResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Trading.Proto.SettingsRequest, global::Trading.Proto.SettingsResponse> __Method_GetSettings = new grpc::Method<global::Trading.Proto.SettingsRequest, global::Trading.Proto.SettingsResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "GetSettings",
        __Marshaller_trading_SettingsRequest,
        __Marshaller_trading_SettingsResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Trading.Proto.HeartbeatRequest, global::Trading.Proto.HeartbeatResponse> __Method_SystemHeartbeat = new grpc::Method<global::Trading.Proto.HeartbeatRequest, global::Trading.Proto.HeartbeatResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SystemHeartbeat",
        __Marshaller_trading_HeartbeatRequest,
        __Marshaller_trading_HeartbeatResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Trading.Proto.HedgeCloseNotification, global::Trading.Proto.GenericResponse> __Method_NTCloseHedge = new grpc::Method<global::Trading.Proto.HedgeCloseNotification, global::Trading.Proto.GenericResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "NTCloseHedge",
        __Marshaller_trading_HedgeCloseNotification,
        __Marshaller_trading_GenericResponse);

    /// <summary>Service descriptor</summary>
    public static global::Google.Protobuf.Reflection.ServiceDescriptor Descriptor
    {
      get { return global::Trading.Proto.TradingReflection.Descriptor.Services[0]; }
    }

    /// <summary>Base class for server-side implementations of TradingService</summary>
    [grpc::BindServiceMethod(typeof(TradingService), "BindService")]
    public abstract partial class TradingServiceBase
    {
      /// <summary>
      /// Trade submission from NinjaTrader
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Trading.Proto.GenericResponse> SubmitTrade(global::Trading.Proto.Trade request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Trade polling for MT5 (streaming)
      /// </summary>
      /// <param name="requestStream">Used for reading requests from the client.</param>
      /// <param name="responseStream">Used for sending responses back to the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>A task indicating completion of the handler.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task GetTrades(grpc::IAsyncStreamReader<global::Trading.Proto.GetTradesRequest> requestStream, grpc::IServerStreamWriter<global::Trading.Proto.Trade> responseStream, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Trade result from MT5
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Trading.Proto.GenericResponse> SubmitTradeResult(global::Trading.Proto.MT5TradeResult request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Hedge closure notifications
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Trading.Proto.GenericResponse> NotifyHedgeClose(global::Trading.Proto.HedgeCloseNotification request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Elastic hedge updates
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Trading.Proto.GenericResponse> SubmitElasticUpdate(global::Trading.Proto.ElasticHedgeUpdate request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Trailing stop updates
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Trading.Proto.GenericResponse> SubmitTrailingUpdate(global::Trading.Proto.TrailingStopUpdate request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Health check
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Trading.Proto.HealthResponse> HealthCheck(global::Trading.Proto.HealthRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Settings API
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Trading.Proto.SettingsResponse> GetSettings(global::Trading.Proto.SettingsRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// System heartbeat
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Trading.Proto.HeartbeatResponse> SystemHeartbeat(global::Trading.Proto.HeartbeatRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// NT close hedge request
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Trading.Proto.GenericResponse> NTCloseHedge(global::Trading.Proto.HedgeCloseNotification request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

    }

    /// <summary>Client for TradingService</summary>
    public partial class TradingServiceClient : grpc::ClientBase<TradingServiceClient>
    {
      /// <summary>Creates a new client for TradingService</summary>
      /// <param name="channel">The channel to use to make remote calls.</param>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public TradingServiceClient(grpc::ChannelBase channel) : base(channel)
      {
      }
      /// <summary>Creates a new client for TradingService that uses a custom <c>CallInvoker</c>.</summary>
      /// <param name="callInvoker">The callInvoker to use to make remote calls.</param>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public TradingServiceClient(grpc::CallInvoker callInvoker) : base(callInvoker)
      {
      }
      /// <summary>Protected parameterless constructor to allow creation of test doubles.</summary>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      protected TradingServiceClient() : base()
      {
      }
      /// <summary>Protected constructor to allow creation of configured clients.</summary>
      /// <param name="configuration">The client configuration.</param>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      protected TradingServiceClient(ClientBaseConfiguration configuration) : base(configuration)
      {
      }

      /// <summary>
      /// Trade submission from NinjaTrader
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Trading.Proto.GenericResponse SubmitTrade(global::Trading.Proto.Trade request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SubmitTrade(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Trade submission from NinjaTrader
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Trading.Proto.GenericResponse SubmitTrade(global::Trading.Proto.Trade request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SubmitTrade, null, options, request);
      }
      /// <summary>
      /// Trade submission from NinjaTrader
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Trading.Proto.GenericResponse> SubmitTradeAsync(global::Trading.Proto.Trade request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SubmitTradeAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Trade submission from NinjaTrader
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Trading.Proto.GenericResponse> SubmitTradeAsync(global::Trading.Proto.Trade request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SubmitTrade, null, options, request);
      }
      /// <summary>
      /// Trade polling for MT5 (streaming)
      /// </summary>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncDuplexStreamingCall<global::Trading.Proto.GetTradesRequest, global::Trading.Proto.Trade> GetTrades(grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetTrades(new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Trade polling for MT5 (streaming)
      /// </summary>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncDuplexStreamingCall<global::Trading.Proto.GetTradesRequest, global::Trading.Proto.Trade> GetTrades(grpc::CallOptions options)
      {
        return CallInvoker.AsyncDuplexStreamingCall(__Method_GetTrades, null, options);
      }
      /// <summary>
      /// Trade result from MT5
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Trading.Proto.GenericResponse SubmitTradeResult(global::Trading.Proto.MT5TradeResult request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SubmitTradeResult(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Trade result from MT5
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Trading.Proto.GenericResponse SubmitTradeResult(global::Trading.Proto.MT5TradeResult request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SubmitTradeResult, null, options, request);
      }
      /// <summary>
      /// Trade result from MT5
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Trading.Proto.GenericResponse> SubmitTradeResultAsync(global::Trading.Proto.MT5TradeResult request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SubmitTradeResultAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Trade result from MT5
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Trading.Proto.GenericResponse> SubmitTradeResultAsync(global::Trading.Proto.MT5TradeResult request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SubmitTradeResult, null, options, request);
      }
      /// <summary>
      /// Hedge closure notifications
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Trading.Proto.GenericResponse NotifyHedgeClose(global::Trading.Proto.HedgeCloseNotification request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return NotifyHedgeClose(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Hedge closure notifications
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Trading.Proto.GenericResponse NotifyHedgeClose(global::Trading.Proto.HedgeCloseNotification request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_NotifyHedgeClose, null, options, request);
      }
      /// <summary>
      /// Hedge closure notifications
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Trading.Proto.GenericResponse> NotifyHedgeCloseAsync(global::Trading.Proto.HedgeCloseNotification request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return NotifyHedgeCloseAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Hedge closure notifications
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Trading.Proto.GenericResponse> NotifyHedgeCloseAsync(global::Trading.Proto.HedgeCloseNotification request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_NotifyHedgeClose, null, options, request);
      }
      /// <summary>
      /// Elastic hedge updates
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Trading.Proto.GenericResponse SubmitElasticUpdate(global::Trading.Proto.ElasticHedgeUpdate request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SubmitElasticUpdate(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Elastic hedge updates
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Trading.Proto.GenericResponse SubmitElasticUpdate(global::Trading.Proto.ElasticHedgeUpdate request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SubmitElasticUpdate, null, options, request);
      }
      /// <summary>
      /// Elastic hedge updates
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Trading.Proto.GenericResponse> SubmitElasticUpdateAsync(global::Trading.Proto.ElasticHedgeUpdate request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SubmitElasticUpdateAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Elastic hedge updates
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Trading.Proto.GenericResponse> SubmitElasticUpdateAsync(global::Trading.Proto.ElasticHedgeUpdate request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SubmitElasticUpdate, null, options, request);
      }
      /// <summary>
      /// Trailing stop updates
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Trading.Proto.GenericResponse SubmitTrailingUpdate(global::Trading.Proto.TrailingStopUpdate request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SubmitTrailingUpdate(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Trailing stop updates
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Trading.Proto.GenericResponse SubmitTrailingUpdate(global::Trading.Proto.TrailingStopUpdate request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SubmitTrailingUpdate, null, options, request);
      }
      /// <summary>
      /// Trailing stop updates
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Trading.Proto.GenericResponse> SubmitTrailingUpdateAsync(global::Trading.Proto.TrailingStopUpdate request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SubmitTrailingUpdateAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Trailing stop updates
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Trading.Proto.GenericResponse> SubmitTrailingUpdateAsync(global::Trading.Proto.TrailingStopUpdate request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SubmitTrailingUpdate, null, options, request);
      }
      /// <summary>
      /// Health check
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Trading.Proto.HealthResponse HealthCheck(global::Trading.Proto.HealthRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return HealthCheck(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Health check
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Trading.Proto.HealthResponse HealthCheck(global::Trading.Proto.HealthRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_HealthCheck, null, options, request);
      }
      /// <summary>
      /// Health check
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Trading.Proto.HealthResponse> HealthCheckAsync(global::Trading.Proto.HealthRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return HealthCheckAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Health check
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Trading.Proto.HealthResponse> HealthCheckAsync(global::Trading.Proto.HealthRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_HealthCheck, null, options, request);
      }
      /// <summary>
      /// Settings API
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Trading.Proto.SettingsResponse GetSettings(global::Trading.Proto.SettingsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetSettings(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Settings API
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Trading.Proto.SettingsResponse GetSettings(global::Trading.Proto.SettingsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_GetSettings, null, options, request);
      }
      /// <summary>
      /// Settings API
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Trading.Proto.SettingsResponse> GetSettingsAsync(global::Trading.Proto.SettingsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetSettingsAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Settings API
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Trading.Proto.SettingsResponse> GetSettingsAsync(global::Trading.Proto.SettingsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_GetSettings, null, options, request);
      }
      /// <summary>
      /// System heartbeat
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Trading.Proto.HeartbeatResponse SystemHeartbeat(global::Trading.Proto.HeartbeatRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SystemHeartbeat(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// System heartbeat
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Trading.Proto.HeartbeatResponse SystemHeartbeat(global::Trading.Proto.HeartbeatRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SystemHeartbeat, null, options, request);
      }
      /// <summary>
      /// System heartbeat
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Trading.Proto.HeartbeatResponse> SystemHeartbeatAsync(global::Trading.Proto.HeartbeatRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SystemHeartbeatAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// System heartbeat
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Trading.Proto.HeartbeatResponse> SystemHeartbeatAsync(global::Trading.Proto.HeartbeatRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SystemHeartbeat, null, options, request);
      }
      /// <summary>
      /// NT close hedge request
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Trading.Proto.GenericResponse NTCloseHedge(global::Trading.Proto.HedgeCloseNotification request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return NTCloseHedge(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// NT close hedge request
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Trading.Proto.GenericResponse NTCloseHedge(global::Trading.Proto.HedgeCloseNotification request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_NTCloseHedge, null, options, request);
      }
      /// <summary>
      /// NT close hedge request
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Trading.Proto.GenericResponse> NTCloseHedgeAsync(global::Trading.Proto.HedgeCloseNotification request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return NTCloseHedgeAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// NT close hedge request
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Trading.Proto.GenericResponse> NTCloseHedgeAsync(global::Trading.Proto.HedgeCloseNotification request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_NTCloseHedge, null, options, request);
      }
      /// <summary>Creates a new instance of client from given <c>ClientBaseConfiguration</c>.</summary>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      protected override TradingServiceClient NewInstance(ClientBaseConfiguration configuration)
      {
        return new TradingServiceClient(configuration);
      }
    }

    /// <summary>Creates service definition that can be registered with a server</summary>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public static grpc::ServerServiceDefinition BindService(TradingServiceBase serviceImpl)
    {
      return grpc::ServerServiceDefinition.CreateBuilder()
          .AddMethod(__Method_SubmitTrade, serviceImpl.SubmitTrade)
          .AddMethod(__Method_GetTrades, serviceImpl.GetTrades)
          .AddMethod(__Method_SubmitTradeResult, serviceImpl.SubmitTradeResult)
          .AddMethod(__Method_NotifyHedgeClose, serviceImpl.NotifyHedgeClose)
          .AddMethod(__Method_SubmitElasticUpdate, serviceImpl.SubmitElasticUpdate)
          .AddMethod(__Method_SubmitTrailingUpdate, serviceImpl.SubmitTrailingUpdate)
          .AddMethod(__Method_HealthCheck, serviceImpl.HealthCheck)
          .AddMethod(__Method_GetSettings, serviceImpl.GetSettings)
          .AddMethod(__Method_SystemHeartbeat, serviceImpl.SystemHeartbeat)
          .AddMethod(__Method_NTCloseHedge, serviceImpl.NTCloseHedge).Build();
    }

    /// <summary>Register service method with a service binder with or without implementation. Useful when customizing the service binding logic.
    /// Note: this method is part of an experimental API that can change or be removed without any prior notice.</summary>
    /// <param name="serviceBinder">Service methods will be bound by calling <c>AddMethod</c> on this object.</param>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public static void BindService(grpc::ServiceBinderBase serviceBinder, TradingServiceBase serviceImpl)
    {
      serviceBinder.AddMethod(__Method_SubmitTrade, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Trading.Proto.Trade, global::Trading.Proto.GenericResponse>(serviceImpl.SubmitTrade));
      serviceBinder.AddMethod(__Method_GetTrades, serviceImpl == null ? null : new grpc::DuplexStreamingServerMethod<global::Trading.Proto.GetTradesRequest, global::Trading.Proto.Trade>(serviceImpl.GetTrades));
      serviceBinder.AddMethod(__Method_SubmitTradeResult, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Trading.Proto.MT5TradeResult, global::Trading.Proto.GenericResponse>(serviceImpl.SubmitTradeResult));
      serviceBinder.AddMethod(__Method_NotifyHedgeClose, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Trading.Proto.HedgeCloseNotification, global::Trading.Proto.GenericResponse>(serviceImpl.NotifyHedgeClose));
      serviceBinder.AddMethod(__Method_SubmitElasticUpdate, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Trading.Proto.ElasticHedgeUpdate, global::Trading.Proto.GenericResponse>(serviceImpl.SubmitElasticUpdate));
      serviceBinder.AddMethod(__Method_SubmitTrailingUpdate, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Trading.Proto.TrailingStopUpdate, global::Trading.Proto.GenericResponse>(serviceImpl.SubmitTrailingUpdate));
      serviceBinder.AddMethod(__Method_HealthCheck, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Trading.Proto.HealthRequest, global::Trading.Proto.HealthResponse>(serviceImpl.HealthCheck));
      serviceBinder.AddMethod(__Method_GetSettings, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Trading.Proto.SettingsRequest, global::Trading.Proto.SettingsResponse>(serviceImpl.GetSettings));
      serviceBinder.AddMethod(__Method_SystemHeartbeat, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Trading.Proto.HeartbeatRequest, global::Trading.Proto.HeartbeatResponse>(serviceImpl.SystemHeartbeat));
      serviceBinder.AddMethod(__Method_NTCloseHedge, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Trading.Proto.HedgeCloseNotification, global::Trading.Proto.GenericResponse>(serviceImpl.NTCloseHedge));
    }

  }
  /// <summary>
  /// Real-time streaming service
  /// </summary>
  public static partial class StreamingService
  {
    static readonly string __ServiceName = "trading.StreamingService";

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static void __Helper_SerializeMessage(global::Google.Protobuf.IMessage message, grpc::SerializationContext context)
    {
      #if !GRPC_DISABLE_PROTOBUF_BUFFER_SERIALIZATION
      if (message is global::Google.Protobuf.IBufferMessage)
      {
        context.SetPayloadLength(message.CalculateSize());
        global::Google.Protobuf.MessageExtensions.WriteTo(message, context.GetBufferWriter());
        context.Complete();
        return;
      }
      #endif
      context.Complete(global::Google.Protobuf.MessageExtensions.ToByteArray(message));
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static class __Helper_MessageCache<T>
    {
      public static readonly bool IsBufferMessage = global::System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(global::Google.Protobuf.IBufferMessage)).IsAssignableFrom(typeof(T));
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static T __Helper_DeserializeMessage<T>(grpc::DeserializationContext context, global::Google.Protobuf.MessageParser<T> parser) where T : global::Google.Protobuf.IMessage<T>
    {
      #if !GRPC_DISABLE_PROTOBUF_BUFFER_SERIALIZATION
      if (__Helper_MessageCache<T>.IsBufferMessage)
      {
        return parser.ParseFrom(context.PayloadAsReadOnlySequence());
      }
      #endif
      return parser.ParseFrom(context.PayloadAsNewBuffer());
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Trading.Proto.Trade> __Marshaller_trading_Trade = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Trading.Proto.Trade.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Trading.Proto.HealthRequest> __Marshaller_trading_HealthRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Trading.Proto.HealthRequest.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Trading.Proto.HealthResponse> __Marshaller_trading_HealthResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Trading.Proto.HealthResponse.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Trading.Proto.ElasticHedgeUpdate> __Marshaller_trading_ElasticHedgeUpdate = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Trading.Proto.ElasticHedgeUpdate.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Trading.Proto.GenericResponse> __Marshaller_trading_GenericResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Trading.Proto.GenericResponse.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Trading.Proto.TrailingStopUpdate> __Marshaller_trading_TrailingStopUpdate = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Trading.Proto.TrailingStopUpdate.Parser));

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Trading.Proto.Trade, global::Trading.Proto.Trade> __Method_TradingStream = new grpc::Method<global::Trading.Proto.Trade, global::Trading.Proto.Trade>(
        grpc::MethodType.DuplexStreaming,
        __ServiceName,
        "TradingStream",
        __Marshaller_trading_Trade,
        __Marshaller_trading_Trade);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Trading.Proto.HealthRequest, global::Trading.Proto.HealthResponse> __Method_StatusStream = new grpc::Method<global::Trading.Proto.HealthRequest, global::Trading.Proto.HealthResponse>(
        grpc::MethodType.DuplexStreaming,
        __ServiceName,
        "StatusStream",
        __Marshaller_trading_HealthRequest,
        __Marshaller_trading_HealthResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Trading.Proto.ElasticHedgeUpdate, global::Trading.Proto.GenericResponse> __Method_ElasticUpdatesStream = new grpc::Method<global::Trading.Proto.ElasticHedgeUpdate, global::Trading.Proto.GenericResponse>(
        grpc::MethodType.DuplexStreaming,
        __ServiceName,
        "ElasticUpdatesStream",
        __Marshaller_trading_ElasticHedgeUpdate,
        __Marshaller_trading_GenericResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Trading.Proto.TrailingStopUpdate, global::Trading.Proto.GenericResponse> __Method_TrailingUpdatesStream = new grpc::Method<global::Trading.Proto.TrailingStopUpdate, global::Trading.Proto.GenericResponse>(
        grpc::MethodType.DuplexStreaming,
        __ServiceName,
        "TrailingUpdatesStream",
        __Marshaller_trading_TrailingStopUpdate,
        __Marshaller_trading_GenericResponse);

    /// <summary>Service descriptor</summary>
    public static global::Google.Protobuf.Reflection.ServiceDescriptor Descriptor
    {
      get { return global::Trading.Proto.TradingReflection.Descriptor.Services[1]; }
    }

    /// <summary>Base class for server-side implementations of StreamingService</summary>
    [grpc::BindServiceMethod(typeof(StreamingService), "BindService")]
    public abstract partial class StreamingServiceBase
    {
      /// <summary>
      /// Bidirectional streaming for real-time updates
      /// </summary>
      /// <param name="requestStream">Used for reading requests from the client.</param>
      /// <param name="responseStream">Used for sending responses back to the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>A task indicating completion of the handler.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task TradingStream(grpc::IAsyncStreamReader<global::Trading.Proto.Trade> requestStream, grpc::IServerStreamWriter<global::Trading.Proto.Trade> responseStream, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Status updates stream
      /// </summary>
      /// <param name="requestStream">Used for reading requests from the client.</param>
      /// <param name="responseStream">Used for sending responses back to the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>A task indicating completion of the handler.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task StatusStream(grpc::IAsyncStreamReader<global::Trading.Proto.HealthRequest> requestStream, grpc::IServerStreamWriter<global::Trading.Proto.HealthResponse> responseStream, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Elastic hedge updates stream
      /// </summary>
      /// <param name="requestStream">Used for reading requests from the client.</param>
      /// <param name="responseStream">Used for sending responses back to the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>A task indicating completion of the handler.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task ElasticUpdatesStream(grpc::IAsyncStreamReader<global::Trading.Proto.ElasticHedgeUpdate> requestStream, grpc::IServerStreamWriter<global::Trading.Proto.GenericResponse> responseStream, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Trailing stop updates stream
      /// </summary>
      /// <param name="requestStream">Used for reading requests from the client.</param>
      /// <param name="responseStream">Used for sending responses back to the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>A task indicating completion of the handler.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task TrailingUpdatesStream(grpc::IAsyncStreamReader<global::Trading.Proto.TrailingStopUpdate> requestStream, grpc::IServerStreamWriter<global::Trading.Proto.GenericResponse> responseStream, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

    }

    /// <summary>Client for StreamingService</summary>
    public partial class StreamingServiceClient : grpc::ClientBase<StreamingServiceClient>
    {
      /// <summary>Creates a new client for StreamingService</summary>
      /// <param name="channel">The channel to use to make remote calls.</param>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public StreamingServiceClient(grpc::ChannelBase channel) : base(channel)
      {
      }
      /// <summary>Creates a new client for StreamingService that uses a custom <c>CallInvoker</c>.</summary>
      /// <param name="callInvoker">The callInvoker to use to make remote calls.</param>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public StreamingServiceClient(grpc::CallInvoker callInvoker) : base(callInvoker)
      {
      }
      /// <summary>Protected parameterless constructor to allow creation of test doubles.</summary>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      protected StreamingServiceClient() : base()
      {
      }
      /// <summary>Protected constructor to allow creation of configured clients.</summary>
      /// <param name="configuration">The client configuration.</param>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      protected StreamingServiceClient(ClientBaseConfiguration configuration) : base(configuration)
      {
      }

      /// <summary>
      /// Bidirectional streaming for real-time updates
      /// </summary>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncDuplexStreamingCall<global::Trading.Proto.Trade, global::Trading.Proto.Trade> TradingStream(grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return TradingStream(new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Bidirectional streaming for real-time updates
      /// </summary>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncDuplexStreamingCall<global::Trading.Proto.Trade, global::Trading.Proto.Trade> TradingStream(grpc::CallOptions options)
      {
        return CallInvoker.AsyncDuplexStreamingCall(__Method_TradingStream, null, options);
      }
      /// <summary>
      /// Status updates stream
      /// </summary>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncDuplexStreamingCall<global::Trading.Proto.HealthRequest, global::Trading.Proto.HealthResponse> StatusStream(grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return StatusStream(new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Status updates stream
      /// </summary>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncDuplexStreamingCall<global::Trading.Proto.HealthRequest, global::Trading.Proto.HealthResponse> StatusStream(grpc::CallOptions options)
      {
        return CallInvoker.AsyncDuplexStreamingCall(__Method_StatusStream, null, options);
      }
      /// <summary>
      /// Elastic hedge updates stream
      /// </summary>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncDuplexStreamingCall<global::Trading.Proto.ElasticHedgeUpdate, global::Trading.Proto.GenericResponse> ElasticUpdatesStream(grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ElasticUpdatesStream(new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Elastic hedge updates stream
      /// </summary>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncDuplexStreamingCall<global::Trading.Proto.ElasticHedgeUpdate, global::Trading.Proto.GenericResponse> ElasticUpdatesStream(grpc::CallOptions options)
      {
        return CallInvoker.AsyncDuplexStreamingCall(__Method_ElasticUpdatesStream, null, options);
      }
      /// <summary>
      /// Trailing stop updates stream
      /// </summary>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncDuplexStreamingCall<global::Trading.Proto.TrailingStopUpdate, global::Trading.Proto.GenericResponse> TrailingUpdatesStream(grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return TrailingUpdatesStream(new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Trailing stop updates stream
      /// </summary>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncDuplexStreamingCall<global::Trading.Proto.TrailingStopUpdate, global::Trading.Proto.GenericResponse> TrailingUpdatesStream(grpc::CallOptions options)
      {
        return CallInvoker.AsyncDuplexStreamingCall(__Method_TrailingUpdatesStream, null, options);
      }
      /// <summary>Creates a new instance of client from given <c>ClientBaseConfiguration</c>.</summary>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      protected override StreamingServiceClient NewInstance(ClientBaseConfiguration configuration)
      {
        return new StreamingServiceClient(configuration);
      }
    }

    /// <summary>Creates service definition that can be registered with a server</summary>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public static grpc::ServerServiceDefinition BindService(StreamingServiceBase serviceImpl)
    {
      return grpc::ServerServiceDefinition.CreateBuilder()
          .AddMethod(__Method_TradingStream, serviceImpl.TradingStream)
          .AddMethod(__Method_StatusStream, serviceImpl.StatusStream)
          .AddMethod(__Method_ElasticUpdatesStream, serviceImpl.ElasticUpdatesStream)
          .AddMethod(__Method_TrailingUpdatesStream, serviceImpl.TrailingUpdatesStream).Build();
    }

    /// <summary>Register service method with a service binder with or without implementation. Useful when customizing the service binding logic.
    /// Note: this method is part of an experimental API that can change or be removed without any prior notice.</summary>
    /// <param name="serviceBinder">Service methods will be bound by calling <c>AddMethod</c> on this object.</param>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public static void BindService(grpc::ServiceBinderBase serviceBinder, StreamingServiceBase serviceImpl)
    {
      serviceBinder.AddMethod(__Method_TradingStream, serviceImpl == null ? null : new grpc::DuplexStreamingServerMethod<global::Trading.Proto.Trade, global::Trading.Proto.Trade>(serviceImpl.TradingStream));
      serviceBinder.AddMethod(__Method_StatusStream, serviceImpl == null ? null : new grpc::DuplexStreamingServerMethod<global::Trading.Proto.HealthRequest, global::Trading.Proto.HealthResponse>(serviceImpl.StatusStream));
      serviceBinder.AddMethod(__Method_ElasticUpdatesStream, serviceImpl == null ? null : new grpc::DuplexStreamingServerMethod<global::Trading.Proto.ElasticHedgeUpdate, global::Trading.Proto.GenericResponse>(serviceImpl.ElasticUpdatesStream));
      serviceBinder.AddMethod(__Method_TrailingUpdatesStream, serviceImpl == null ? null : new grpc::DuplexStreamingServerMethod<global::Trading.Proto.TrailingStopUpdate, global::Trading.Proto.GenericResponse>(serviceImpl.TrailingUpdatesStream));
    }

  }
  /// <summary>
  /// Logging service (initially unary; can evolve to streaming later)
  /// </summary>
  public static partial class LoggingService
  {
    static readonly string __ServiceName = "trading.LoggingService";

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static void __Helper_SerializeMessage(global::Google.Protobuf.IMessage message, grpc::SerializationContext context)
    {
      #if !GRPC_DISABLE_PROTOBUF_BUFFER_SERIALIZATION
      if (message is global::Google.Protobuf.IBufferMessage)
      {
        context.SetPayloadLength(message.CalculateSize());
        global::Google.Protobuf.MessageExtensions.WriteTo(message, context.GetBufferWriter());
        context.Complete();
        return;
      }
      #endif
      context.Complete(global::Google.Protobuf.MessageExtensions.ToByteArray(message));
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static class __Helper_MessageCache<T>
    {
      public static readonly bool IsBufferMessage = global::System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(global::Google.Protobuf.IBufferMessage)).IsAssignableFrom(typeof(T));
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static T __Helper_DeserializeMessage<T>(grpc::DeserializationContext context, global::Google.Protobuf.MessageParser<T> parser) where T : global::Google.Protobuf.IMessage<T>
    {
      #if !GRPC_DISABLE_PROTOBUF_BUFFER_SERIALIZATION
      if (__Helper_MessageCache<T>.IsBufferMessage)
      {
        return parser.ParseFrom(context.PayloadAsReadOnlySequence());
      }
      #endif
      return parser.ParseFrom(context.PayloadAsNewBuffer());
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Trading.Proto.LogEvent> __Marshaller_trading_LogEvent = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Trading.Proto.LogEvent.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Trading.Proto.LogAck> __Marshaller_trading_LogAck = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Trading.Proto.LogAck.Parser));

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Trading.Proto.LogEvent, global::Trading.Proto.LogAck> __Method_Log = new grpc::Method<global::Trading.Proto.LogEvent, global::Trading.Proto.LogAck>(
        grpc::MethodType.Unary,
        __ServiceName,
        "Log",
        __Marshaller_trading_LogEvent,
        __Marshaller_trading_LogAck);

    /// <summary>Service descriptor</summary>
    public static global::Google.Protobuf.Reflection.ServiceDescriptor Descriptor
    {
      get { return global::Trading.Proto.TradingReflection.Descriptor.Services[2]; }
    }

    /// <summary>Base class for server-side implementations of LoggingService</summary>
    [grpc::BindServiceMethod(typeof(LoggingService), "BindService")]
    public abstract partial class LoggingServiceBase
    {
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Trading.Proto.LogAck> Log(global::Trading.Proto.LogEvent request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

    }

    /// <summary>Client for LoggingService</summary>
    public partial class LoggingServiceClient : grpc::ClientBase<LoggingServiceClient>
    {
      /// <summary>Creates a new client for LoggingService</summary>
      /// <param name="channel">The channel to use to make remote calls.</param>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public LoggingServiceClient(grpc::ChannelBase channel) : base(channel)
      {
      }
      /// <summary>Creates a new client for LoggingService that uses a custom <c>CallInvoker</c>.</summary>
      /// <param name="callInvoker">The callInvoker to use to make remote calls.</param>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public LoggingServiceClient(grpc::CallInvoker callInvoker) : base(callInvoker)
      {
      }
      /// <summary>Protected parameterless constructor to allow creation of test doubles.</summary>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      protected LoggingServiceClient() : base()
      {
      }
      /// <summary>Protected constructor to allow creation of configured clients.</summary>
      /// <param name="configuration">The client configuration.</param>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      protected LoggingServiceClient(ClientBaseConfiguration configuration) : base(configuration)
      {
      }

      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Trading.Proto.LogAck Log(global::Trading.Proto.LogEvent request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return Log(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Trading.Proto.LogAck Log(global::Trading.Proto.LogEvent request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_Log, null, options, request);
      }
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Trading.Proto.LogAck> LogAsync(global::Trading.Proto.LogEvent request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return LogAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Trading.Proto.LogAck> LogAsync(global::Trading.Proto.LogEvent request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_Log, null, options, request);
      }
      /// <summary>Creates a new instance of client from given <c>ClientBaseConfiguration</c>.</summary>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      protected override LoggingServiceClient NewInstance(ClientBaseConfiguration configuration)
      {
        return new LoggingServiceClient(configuration);
      }
    }

    /// <summary>Creates service definition that can be registered with a server</summary>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public static grpc::ServerServiceDefinition BindService(LoggingServiceBase serviceImpl)
    {
      return grpc::ServerServiceDefinition.CreateBuilder()
          .AddMethod(__Method_Log, serviceImpl.Log).Build();
    }

    /// <summary>Register service method with a service binder with or without implementation. Useful when customizing the service binding logic.
    /// Note: this method is part of an experimental API that can change or be removed without any prior notice.</summary>
    /// <param name="serviceBinder">Service methods will be bound by calling <c>AddMethod</c> on this object.</param>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public static void BindService(grpc::ServiceBinderBase serviceBinder, LoggingServiceBase serviceImpl)
    {
      serviceBinder.AddMethod(__Method_Log, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Trading.Proto.LogEvent, global::Trading.Proto.LogAck>(serviceImpl.Log));
    }

  }
}
#endregion
